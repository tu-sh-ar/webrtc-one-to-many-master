const express = require("express");

const bodyParser = require("body-parser");

const webrtc = require("wrtc");

const path = require("path");



var server = require('http').createServer((req, res) => res.end());
var io = require('socket.io')(server);

server.listen(process.env.PORT || 3000,() => console.log("\nserver listening"));

const app = express();

// app.use(express.static(path.join(__dirname, "/public")));

// app.use(bodyParser.json());

// app.use(bodyParser.urlencoded({ extended: true }));

let senderStream;

let user = null;


// When a WebSocket connection is established, create an RTCPeerConnection

io.on("connection", (socket) => {
  

  const user = socket.handshake.query.user;

  console.log("USER", user);

  const configuration = {
    iceServers: [
      {
        urls: "stun:stun.l.google.com:19302",
      },
      {
        urls: "stun:stun1.l.google.com:19302",
      },
      {
        urls: "stun:stun2.l.google.com:19302",
      },
      {
        urls: 'turn:openrelay.metered.ca:80',
        username: 'openrelayproject',
        credentials: 'openrelayproject'
      }
    ],
  };

  const peerConnection = new webrtc.RTCPeerConnection(configuration); // When an ICE candidate is generated by the peerConnection, send it to the client

  peerConnection.addEventListener("icecandidate", (event) => {
    if (event.candidate) {
      socket.emit("message",
        JSON.stringify({ type: "icecandidate", candidate: event.candidate })
      );
    }
  });

  peerConnection.ontrack = (e) => handleTrackEvent(e); 
  // When an offer is received from the client, set it as the remote description and create an answer

  socket.on("message", async (message) => {

    const parsedMessage = JSON.parse(message); // console.log("Message", parsedMessage);

    if (parsedMessage.type === "offer") {
      await peerConnection.setRemoteDescription(
        new webrtc.RTCSessionDescription(parsedMessage.offer)
      );

      if (user === "viewer") {
        console.log("\n attach streams ", senderStream);
        senderStream
          .getTracks()
          .forEach((track) => peerConnection.addTrack(track, senderStream));
      }

      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      console.log("\nSend sdp Answer in socket---");
      socket.emit("message",JSON.stringify({ type: "answer", answer: answer }));
    } 
    else if (parsedMessage.type === "icecandidate") {
      console.log("\nICE Added----", parsedMessage.candidate);
      await peerConnection
        .addIceCandidate(new webrtc.RTCIceCandidate(parsedMessage.candidate))
        .then(() => console.log("\nICE ADDED"))
        .catch((err) => console.log("\nError in ice", err));
    }
  });
});

function handleTrackEvent(e, peer) {
   console.log("----HANDLE TRACK EVENTS CALLED-----------", e);
   console.log("--STREAM RECEIVED--", e.streams[0]);
   senderStream = e.streams[0];
}

app.get("/", (req, res) => {
    res.send("Hello World!");
  });